## R Extensions in C versus C++: Judging Size, Speed, and Ease of Use for the Fibonacci Recursion

Just as in the case of the 
[sibbling repo for the convolution example](https://github.com/eddelbuettel/rcpp_comparison_convolution), 
nothing in this repo is entirely new as the [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci) sequence is 
very well studied indeed. For example, [my Rcpp book](http://www.rcpp.org/book/) covers it extensively as the running
introductory example showing a pretty large number of different implementations to contrast languages and algorithms.  

But just as in the other repo, we thought it would be worthwhile to quickly cook them up as _packages_ to compare 
the final installed size, as well as performance, between both C, posited by some as "easier" for R extension, and Rcpp. 
We are doing this again with a script `compare.R` which installs these packages (directly from this repo) unless they are
present.  It also uses the 'stripping' feature of the upcoming R 3.6.0 release (due in now three weeks) which I 
[recently blogged about](http://dirk.eddelbuettel.com/blog/2019/03/27#021_stripping_take_three).  The packages
were constructed the same way using [pkgKitten](https://github.com/eddelbuettel/pkgkitten) where the Rcpp use was undone
for the two C packages (for which we added a 'manual' use of `.Call()`).

On my Linux box, after running the `compare.R` script with R-devel, I see the ollowing for the
size of the shared library of the four package versions:

### Sizes

```sh
fibPkgWithoutRcpp    fibPkgWithRcpp 
            14136             64368 
```

So sure. If your life depends on 50 kilobytes, go for it.  You may then want to rethink why you started from a few dozen
megabytes for a bare R installation, or very likely hundreds of megabytes for a working and realistic setup.  But it is
a big world, and we all make choices.  So enjoy the saved fifty kilobytes.  I may continue to work in C++ as I find it easier,
safer and more performant. But mileages vary, as do tastes and preferences in other thing.

### Runtime

Doing a Fibonacci sequence from R as a C extension in the most direct way gets us _fairly brutally underperforming_ performance as 
we detail below.   The code snippet is below. We need to unpack the `SEXP`, we need to allocate (and manually protect to then later 
unprotect matchingly) two temporaries. The whole extends over sixteen lines.  We have the full examples below, but for concreteness 
here it is:

```c
SEXP fibC(SEXP ns) {
    SEXP result = PROTECT(allocVector(REALSXP, 1)); /* real not int for overflow */
    double n = asReal(ns);
    if (n < 2) {
        REAL(result)[0] = n;
        UNPROTECT(1);
        return result;
    }
    SEXP nm1 = PROTECT(allocVector(REALSXP, 1));
    SEXP nm2 = PROTECT(allocVector(REALSXP, 1));
    REAL(nm1)[0] = n - 1;
    REAL(nm2)[0] = n - 2;
    REAL(result)[0] = asReal(fibC(nm1)) + asReal(fibC(nm2));
    UNPROTECT(3);
    return result;
}
```

When I mentioned this (and its _abysmal_ performance, see below) to a friend, I was told that I wasn't fair as the packing and unpacking
for each of the countless function calls a _Fibonacci_ recursion requires would be costly.  Fair enough.  So we set up a second, more 
involved version that has a simpler, narrower, pure C recursion and the manual glue for getting and returning values from/to R.  I think
that neatly shows that there is no such thing as a 'simple' C extensions to R. You very much need to be in this knee-deep and know what
you are doing. 

For comparison, that version I coded up as 

```c
double fib(double n) {
    if (n < 2) return n;
    return fib(n-1) + fib(n-2);
}

SEXP fib2C(SEXP ns) {
    double n = asReal(ns);
    SEXP result = PROTECT(allocVector(REALSXP, 1)); /* real not int for overflow */
    REAL(result)[0] = fib(n);
    UNPROTECT(1);
    return result;
}
```

While two functions, it is much shorter and a little clearer.  Still the `PROTECT`/`UNPROTECT` dance and an explicit 
allocation each time.

Lastly, and very short and sweet, the C++ version using Rcpp.  It does of course have some _autogenerated_ glue code 
that comes with it---hence the difference in size.

```c++
// [[Rcpp::export]]
double fib(double n) {
  if (n < 2) return n;
  return fib(n-1) + fib(n-2);
}
```

By far the most concise and clear to reason about.   Next, let us look at performance for $n=30$ (or a reasonably 
expensive sequence) repeatedly one thousand times:

```sh
Unit: milliseconds
      expr      min       lq      mean    median        uq       max neval
 c_recurse 87.39052 99.83745 103.07350 101.89308 104.81340 152.42525  1000
 c_wrapped  3.76736  3.79812   3.87568   3.82801   3.88514   5.02083  1000
       cpp  2.92774  2.96567   3.03297   3.00406   3.04272   3.85501  1000       
```

`ggplot2::autoplot()` can visualize this:

![microbenchmark of three Fibonacci implementations](comparison.png)


Acknowledging that these vary somewhat from run to run on the same machine, the pattern held. C++ 
clearly beats C that knows what it doing, and both are lightyears ahead of naive C. Morale: if you
do not know what you are doing and do not measure, it is entirely possibly to write disastrously slow
_compiled_ code hoping to gain on R.  

For completeness, the full code examples are below.


### Code Snippets

#### C Code with Recursion over SEXP

```c

#include <R.h>
#include <Rinternals.h>

SEXP fibC(SEXP ns) {
    SEXP result = PROTECT(allocVector(REALSXP, 1)); /* real not int for overflow */
    double n = asReal(ns);
    if (n < 2) {
        REAL(result)[0] = n;
        UNPROTECT(1);
        return result;
    }
    SEXP nm1 = PROTECT(allocVector(REALSXP, 1));
    SEXP nm2 = PROTECT(allocVector(REALSXP, 1));
    REAL(nm1)[0] = n - 1;
    REAL(nm2)[0] = n - 2;
    REAL(result)[0] = asReal(fibC(nm1)) + asReal(fibC(nm2));
    UNPROTECT(3);
    return result;
}
```

#### C Code with SEXP Wrapper for Recursion

```c

#include <R.h>
#include <Rinternals.h>

double fib(double n) {
    if (n < 2) return n;
    return fib(n-1) + fib(n-2);
}

SEXP fib2C(SEXP ns) {
    double n = asReal(ns);
    SEXP result = PROTECT(allocVector(REALSXP, 1)); /* real not int for overflow */
    REAL(result)[0] = fib(n);
    UNPROTECT(1);
    return result;
}
```

#### Standard Rcpp Code

```c++
#include <Rcpp.h>

// [[Rcpp::export]]
double fib(double n) {
  if (n < 2) return n;
  return fib(n-1) + fib(n-2);
}
```
